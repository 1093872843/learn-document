# Vite

## 缺点

1. 开发和生产的不一致性,开发环境，vite以现代浏览器作为目标群众，让vite尽可能地接近原始源代码。生产环境，默认支持现代浏览器，如果项目需要支持旧版浏览器，需要通过官方的 @vitejs/plugin-legacy插件配置。

## 小结

### 为什么vite 开发启动较快（？）

1. 冷启动启动前，需要先构建整个应用为bundle,而vite开发服务器启动后，并未构建全部应用，并且ES6模块的打包工作移交给了浏览器，vite只需要在浏览器请求时源码时进行转换。

### 为什么vite开发更新快（？）

1. 通常重新构建整个包的效率很低，特别是随着应用体积增加，一切打包器会将构建内容存入缓存，这样只需要在文件更改时使模块图的一部分失活，但是仍需要整个重新构建并重载页面，并且重载页面会消除应用的当前状态
2. 大部分打包器支持动态模块热替换（HMR），这大大改进了开发体验，但是随着应用规模额增长，速度依旧会显著下降。
3. 在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。
Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

### 为什么vite使用了ES模块机制，但是仍需要对这些文件进行分析打包操作

1. 尽管vite开发ES模块和静态开发很相似，但不一样，比如静态开发无法支持裸模块导入，vite需要对这些内容进行解析构建,以便浏览器正确导入。
2. 依赖是强缓存的，vite通过HTTP头来缓存请求得到的依赖。
3. 原生 ESM 嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。例如，动态模块A中引入了模块C，未优化情况下，浏览器必须解析A才能知晓并引入模块C，vite会使用一个预加载步骤，分割动态导入调用，以实现A被请求时，C同时被请求。

### 为什么vite不使用ESBuild进行打包

1. Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容，权衡之下使用了Rollup

### 依赖于构建

1. Vite 的*开发*服务器将所有代码视为原生 ES 模块。因此，Vite 必须使用esbuild先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。
2. Vite 为了提高后续页面的加载性能，会将那些具有许多内部模块的 ESM 依赖项转换为单个模块，比如[lodash-es](https://unpkg.com/browse/lodash-es@4.17.21/),从而减少网络请求。
3. 依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。在生产构建中，将使用 @rollup/plugin-commonjs。
4. 在一个 monorepo 启动中，该仓库中的某个包可能会成为另一个包的依赖。Vite 会自动侦测没有从 node_modules 解析的依赖项，并将链接的依赖视为源码。它不会尝试打包被链接的依赖，而是会分析被链接依赖的依赖列表。然而，这需要被链接的依赖被导出为 ESM 格式。如果不是，需要额外配置内容，当对链接的依赖进行更改时，请使用 --force 命令行选项重新启动开发服务器，以使更改生效。

### 模块热替换

1. vite提供了一套原生ESM的HMR API，具有HRM功能的框架可以利用该APPI提供即时准确的更新，而无需重新加载页面或清除应用程序状态。此功能不需要手动配置，当我们通过create-vite创建应用程序时，模板已经预先配置了这些。

## OTHER

1. ES6模块同时支持异步和同步导入，根据import位置不同决定，当import位于顶部时，属于静态同步导入，当import位于代码内部
，属于异步导入，可以使用import().then()进行加载完成后的异步操作
